
----------------
# 后台设计简介
-----------------------
&emsp;&emsp;后台采用Springboot+Mybatis+Mysql的架构，使用Mysql作为数据库，Springboot完成API接口的具体实现，Mybatis作为持久层框架，进行二者间数据交流以及数据的持久化。使用的Springboot为3.1.0版本，Mybatis为3.0.1版本，Mysql为8.0.33版本。依赖文件相关内容如下：
```xml
<parent>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-parent</artifactId>
	<version>3.1.0</version>
	<relativePath/> <!-- lookup parent from repository -->
</parent>
<!--	sql -->
<dependency>
	<groupId>mysql</groupId>
	<artifactId>mysql-connector-java</artifactId>
	<version>8.0.33</version>
	<scope>runtime</scope>
</dependency>
<!--	mybatis-->
<dependency>
	<groupId>org.mybatis.spring.boot</groupId>
	<artifactId>mybatis-spring-boot-starter</artifactId>
	<version>3.0.1</version>
</dependency>
```
&emsp;&emsp;本项目后台的优点是：
&emsp;&emsp;1.结构清晰，进行清晰的分层，对文件依照针对的表名和所在层进行了统一化的命名，文件作用一目了然。
&emsp;&emsp;2.函数结构化强，对于多次使用的部分，封装成为函数，代码修改较为简单。
&emsp;&emsp;3.表单数据结构较为自由，尽量少使用enums、Array等容易因数据结构而产生500错误的结构，允许前台较大程度上修改自身表单内容而不产生报错。
&emsp;&emsp;4.接口命名规范性强，前台使用接口可以较为简单地理解接口含义，配合接口文档可以较为容易地使用接口。


------------------
## 后台代码结构简介
-------------------
&emsp;&emsp;后台代码采用四层架构，分别为Controller层、Service层、Dao层与Model层，其中对应经典的三层架构，Dao层对应数据访问层，Service层与Model层对应业务逻辑层，Controller层对应表示层。
### Controller层
&emsp;&emsp;Controller层共定义21个类，除去测试接口连接使用的TestController类以及关联表单使用的ProcessController与ApplicationController类之外，其他类均各自对应前端一个表单，处理特定表单的增、删、改、查工作，其中定义的接口的作用以及使用规范清请参考《接口文档》。
### Service层
&emsp;&emsp;每个Controller类对应一个Service类，Service类对从Controller层传来的JSONString进行处理，由于前端在JSONString的表单结构与数据命名上与后端和数据库有一定不同，所以需要对绝大部分变量进行重新命名。对于一些变量结构，也会做一定处理：
&emsp;&emsp;1.对于JSONObject中包含其他变量的JSONobject，会去掉JSONObject的打包，将其展开，例如：
```JSON
{
    "key1":"value1",
    "key2":"value2",
    "JSONObject":{
        "key3":"value3",
        "key4":"value4"
    }
}
```
处理为：
```JSON
{
    "key1":"value1",
    "key2":"value2",
    "key3":"value3",
    "key4":"value4"
}
```
在这其中的JSONObject与JSONArray，递归地进行处理，直到没有为止。

&emsp;&emsp;2.对于含有单个变量的JSONArray，直接作为String存储，例如：
```JSON
{
    "JSONArray":[
        "value1",
        "value2",
        "value3",
        ...
    ]
}
```
处理为：
```JSON
{
    "key1":"[value1,value2,value3,...]"
}
```
在这其中的JSONObject与JSONArray，递归地进行处理，直到没有为止。

&emsp;&emsp;3.对于只有一个只含有单个变量的JSONObject的JSONArray，直接展开后作为String存储，例如：
```JSON
{
    "JSONArray":[
        {
            "key":"value"
        },
        {
            "key":"value"
        },
        ...
    ]
}
```
处理为：
```JSON
{
    "key1":["value1","value2","value3",...]
}
```
在这其中的JSONObject与JSONArray，递归地进行处理，直到没有为止。

&emsp;&emsp;<a id = "4"></a>4.对于含有多个变量，或者含有有多个变量的JSONObject的JSONArray，为其中的每一个Array成员建立一个新的JSONObject，建立一个新的Mysql表将其存储，利用Mysql为其建立一个特异性id，同时在原JSONObject上建立一个JSONArray，存储对应的特异性id：
```JSON
{
    "JSONArray":[
        {
            "key1":"value1",
            "key2":"value2"
        },{
            "key1":"value1",
            "key2":"value2"
        },
        ...
    ]
}
```
处理为：
```JSON
父Object:
{
    "JSONArray":["id1","id2",...]
}

子JSONObject1:
{
    "id":"id1",
    "key1":"value1",
    "key2":"value2"
}
子JSONObject2:
{
    "id":"id2",
    "key1":"value1",
    "key2":"value2"
}
...
（其中JSONObject1和JSONObject2存入一个额外的Mysql表当中，id为Mysql返回的主键）
```
在这其中的JSONObject与JSONArray，递归地进行处理，直到没有为止。

&emsp;&emsp;同时，Service层还对上传失败，数据为空，查询失败等情况进行处理，合理地返回各类报错信息，尽可能避免前台收到500错误信息。
&emsp;&emsp;每个Service类都会调用ProcessDao，其余地，至少会使用自身对应的Dao层类，每因为上述第4点而需要额外建立Mysql表进行存储的，就需要额外使用一个Dao层类。

### Dao层
&emsp;&emsp;每一个Dao类被一个Service类所调用（除去ProcessDao，它被所有Service类调用），同时对应一个Mysql的表。Dao层定义了后台与数据库之间的接口，使用Mybatis结合注解，省去了Mapper文件的定义。对于@Select注解的接口，Mybatis会自动调用对应Model文件中的setter函数，按顺序将Mysql返回的数据封装为对应Model的List。对于@Insert注解的接口，使用：
```java
@Options(useGeneratedKeys=true, keyProperty="ID", keyColumn="ID")
```
的注解，在Insert后，Mysql生成的id会被装入对应Model的ID中，
### Model层
&emsp;&emsp;每一个Model类被一个Dao类调用，同时也被调用该Dao类的所有Service类调用。Model类定义每一个表单在后台的结构。其结构对应Service类处理后的数据结构，又与Mysql中对应的表保持一致。除去ID使用Integer类型之外，绝大部分数据以String类型定义，这样做的好处是允许前台更为自由地修改表单的规范，而不需要频繁地通知后台。同时也尽可能地避免了500报错（尤其相比于enum枚举类型而言），而代价仅仅是返回前台时需要进行数据转换而已。

------------------
后台代码UML类图如下图：
![MUL](./pic/demoUML.png)

--------------------------
## 后台数据处理流程
-----------------------
&emsp;&emsp;数据以JSON的形式传入Controller层，根据对应的接口，Controller层调用对应的Service层函数进行处理。所有的表都需要将ID存在Process下，因此，PID（对应委托进程的ID）是至关重要的，Service层首先查看数据当中是否拥有必要的PID，如果没有或者PID是无效的，那么会报错。如果没有问题，那么对传入数据进行处理，拆解JSONObject和Array结构，或者是依照[Service层结构简介第4点](#4)所说，产生额外的JSONObject。
&emsp;&emsp;如果执行的行为是新增（insert），如果产生了额外的JSONObject，那么，先交由子Object对应的Dao层进行存储，然后将对应的id存到父Object中。然后，交给对应的Dao层进行存储。存储之后，Dao层返回具体的ID，调用ProcessDao的对应函数，将ID存在Process下。
&emsp;&emsp;如果执行的行为是查找（select），修改（update）或者说删除（delete），那么根据PID查询对应的ID，然后再使用ID查找具体的信息，如果查找失败，那么报错（查找操作则是返回空Array）；否则，执行对应的操作，然后返回对应信息：查找是返回查找结果，修改和删除返回成功信息，如果是依照[Service层结构简介第4点](#4)所说，要对子Object进行修改，那么查找约定的操作字段，根据字段内容进行对应操作，如果失败，将会在返回信息中额外添加失败的id信息。
&emsp;&emsp;在返回查询过程中，也需要对数据重新命名和封装，这里采用的方式与Service层结构简介中所提到的对前台数据的处理是反向的。
&emsp;&emsp;返回的数据以JSON的形式，由Contorller层返回给前台。

--------------------------------

## 文件上传下载

### 实现概述

文件上传下载是本次项目的核心功能，除了需要实现服务器本地文件IO，还要通过以http协议与前端通信，是
本次实验的技术关键。

- **文件上传**

文件上传通过Spring框架中的`MultipartFile`实现，通过相关接口可轻松解决上传下载。

- `FileController`接收前端传参，转发给`Service`层处理
``` java
@CrossOrigin
@RequestMapping(value="/upload", method = RequestMethod.POST)
public Integer upload(@RequestParam("file") MultipartFile file,
                      @RequestParam("PID") Integer PID,
                      @RequestParam("state") String state,
                      @RequestParam("fileType") String fileType){
                        ...
                        return fileService.upload(file, PID, state, fileType);
                        ...
                      }
```

- `Service`层调用`Dao`层和`FileUtil`分别上传数据库和储存到本地

``` java
    public Integer upload(MultipartFile file, Integer PID, String state, String fileType) throws Exception{
        ...
        String fileName = file.getOriginalFilename();
        String filePath = fileUtil.uploadWithFileInfo(file, PID, state, fileType);
        //fileUtil将文件存储到本地并返回文件本地存储路径
        FileModel fileModel = new FileModel(filePath, PID, fileName);
        ...
        fileDao.upload(fileModel); //将文件信息经由DAO层上传到数据库
        return fileModel.getFID();
        ...
    }
```

- `FileUtil`将文件储存到本地

```java
    @ResponseBody
    public  String uploadWithFileInfo(@RequestPart(value = "file") MultipartFile mf,
                                      @RequestParam(value = "PID") Integer PID,
                                      @RequestParam(value = "state") String state,
                                      @RequestParam(value = "fileType") String fileType) throws IOException {
        //将文件上传到指定文件夹
        if (!mf.isEmpty()){
            String fileName=mf.getOriginalFilename();
            //文件上传
            String finalPath = UPLOAD_FILEPATH + PID.toString() + "\\" + state + fileType +  "_" + fileName ;
            // finalPath将文件信息写入文件名，避免重复命名覆盖
            File finalFile = new File(finalPath);
            if (!finalFile.exists())
                finalFile.mkdirs();
            mf.transferTo(new File(finalPath));
            return finalPath;
        }
        return "";
    }
```

- `FileDao` 将信息上传到mysql数据库
``` java
    @Insert("INSERT INTO selabspringe.file(filePath, PID, fileName, state, fileType) VALUES (#{filePath}, #{PID}, #{fileName}, #{state}, #{fileType})")
    @SelectKey(keyColumn = "FID", before = false, resultType = Integer.class, statement = {"select last_insert_id()"}, keyProperty = "FID")
    void upload(FileModel fileModel);
```

- **文件下载**

文件下载完全通过`FileController`处理，通过`HttpServletResponse`传输，通过文件stream缓冲区stream进行读取

``` java
    @CrossOrigin
    @RequestMapping(value = "/download", method = RequestMethod.POST)
    public String download(@RequestBody String postJson, HttpServletResponse response){
        //  新建文件流，从磁盘读取文件流
        JSONObject jsonObject = JSONObject.parseObject(postJson);
        Integer FID = jsonObject.getInteger("FID");
        FileModel fileModel = fileDao.selectByFID(FID);
        System.out.println(fileModel);
        if(fileModel == null) return "不存在FID为 "+FID.toString() + " 的文件";
        try (FileInputStream fis = new FileInputStream(fileModel.getFilePath());
             BufferedInputStream bis = new BufferedInputStream(fis);
             OutputStream os = response.getOutputStream()) {    
            // fis读取本地文件
            // OutputStream 是文件写出流，将文件下载到浏览器客户端
            // 新建字节数组，长度是文件的大小，比如文件 6kb, bis.available() = 1024 * 6
            byte[] bytes = new byte[bis.available()];
            // 从文件流读取字节到字节数组中
            bis.read(bytes);
            // 重置 response
            response.reset();
            // 设置 response 的下载响应头
            response.setHeader("Access-Control-Allow-Origin","*");
            response.setHeader("Access-Control-Expose-Headers", "Content-disposition");
            response.setContentType("application/octet-stream");
            response.setHeader("Content-disposition", "attachment;filename="
                    + URLEncoder.encode(fileModel.getFileName(), StandardCharsets.UTF_8));
            // 写出字节数组到输出流
            os.write(bytes);
            // 刷新输出流
            os.flush();
        } catch (Exception e) {

            return e.getMessage();
        }
        return "下载任务创建成功";
    }
```

------------------------
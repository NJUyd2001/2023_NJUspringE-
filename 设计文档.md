[TOC]

# 引言

软件测试是基于技术手段验证软件是否满足需求，存在相应的漏洞，从而达到减少代码缺陷，保障软件质量的作用，而本项目旨在为使用者提供一个直观、方便、系统化的交互平台，从而规范其工作步骤，提高软件测试工作的效率、完成质量以及工作体验。

# 项目简介

软件测试平台即为客户打造了集高效率、低成本等特性于一身，大幅缩短了软件产品测试周期，并且可以提升产品品质，同时还能充分发挥虚拟化的优势，减少物理工作站的数量，和降低客户的IT系统能耗、提高了空间使用效率的软件测试工作空间。

<img src="pic/tp204.png" style="zoom: 80%;" />


# 前端设计文档

### 

##  一. 代码结构

### （一）登录、注册设计

#### 	 1. 主界面

​			路径：http://localhost:9090/#/home（本地路径）。vue部分代码设计与主页部分类似，在主页设计部分中我会详细的介绍。在main中，包含两个card，第一个card可直接跳转到客户登录，第二个card可直接跳转到工作人员登录。在设计中，我把用户登录和工作人员登录做了分离。首先，把二者分开可以在一定程度上提高安全性；其二，在设计中，工作人员的账号只能由管理员来注册，而客户的账号则由自己注册，所以在设计中二者也存在差异。综上，我决定把这两个登录界面分开，也能更好的体现结构

![](pic\image-20230716112337440.png)

#### 	 2. 登录界面

​			登录界面包括客户登录和工作人员登录。用户可以通过输入用户名和用户密码登录相应的主页。如果希望注册界面，客户可以直接点击注册以完成注册，而工作人员需要向管理员发起申请。在输入的账户信息匹配成功后，登录函数会把该用户的全部个人信息都保存到this.$store.state.user中，留在日后备用。

![](pic\image-20230716114252565.png)

####     3. 注册界面

​		在客户注册时，客户需要提供的信息有：用户名（不可重复），账户密码，联系方式（不可重复）和用户邮箱（不可重复）。在输入完密码之后需要再次输入密码，两次需要完全相同才可以完成注册。用户输入的全部个人信息都会储存到ruleForm中并传给数据库，注册成功后会自动跳转到登录界面。工作人员的注册只能由管理员完成。与客户注册不同的是，管理员需要选择注册用户的工作，包括：市场部人员，测试部人员，质量部人员，测试部主管和授权签字人。除此之外与客户注册的流程相同。注册成功后，会返回管理员主页。

![](pic\image-20230716115534536.png)

### （二）主页设计

####    1.el-container（主容器）

​         代码的vue部分由el-container负责布局。最外层为el-container,里面包含了el-header与el-container，两个子容器垂直排列。

![](pic\image-20230715195526478.png)

#### 		(1) el-header

​          header中只有一个el-row,该row中包含了三个el-col，它们分别储存了标头，logo和按钮。其中，标头的格式为【用户名】，您好。该格式在全部用户界面中使用，包括：客户主页，市场部主页，测试部主页，测试部主管主页，质量部主页，授权签字人主页和管理员主页。第二部分为logo，logo内容为南京大学软件测试中心，格式为.png，该格式同样适用于全部的用户界面，除去上部分的范围，还有网站主页、用户登录，工作人员登录，与注册界面。第三部分为按钮，包括了个人中心按钮以及登出按钮。其中，点击个人中心按钮会进入个人中心，在个人中心可完成个人信息查看和个人信息修改。点击登出按钮可以跳转回该用户所属用户类型对应的登录界面。

![](pic\image-20230715200340131.png)

#### 		(2) el-container （子容器）

​			该容器包含el-aside与el-container,el-aside是左侧导航栏部分，导航栏包含了一个el-menu,el-menu中包含了数个submenu，每个submenu都可以折叠，在这里存放了该用户的一个主要功能，submenu中同样细化了多个el-menu-item-group，每一个都对应了一项具体的功能，当用户需要使用时可点击该按钮，会在右侧的el-main中打开一个新的table，帮助用户完成工作。除了打开新的table，还有部分功能会打开新的界面以实现功能。这包括：客户发起委托，全部用户完善个人信息。

#### 		(3) el-main

​			main中只有一个el-tabs，当用户需要完成某项工作时，会在左侧导航栏点击相应内容，便会在main出显示出相应的表格，由于工作的单位是单个委托，所以该表格的搜索项就是委托的state（委托的当前状态，即进行到哪部分），根据state确定委托的PID，并把需要的内容打印出来，打印内容：委托ID，进程ID，委托名称，委托发起时间，测试类型与用户ID。

![](pic\image-20230715203641651.png)

#### 		(4) el-footer

​			el-footer的格式如下面所示，只包含一个<p>,其中第一行是“南京大学 计算机软件新技术国家重点实验室 软件测试中心”，第二行是“江苏省 南京市 栖霞区 仙林大道163号南京大学仙林校区计算机科学与技术楼”

![](pic\image-20230715203909072.png)

####    2. script部分

#### 		(1) created()

​			除去包含beforecreated()的文件外，created函数是首先执行的函数。所以，页面中显示的后端数据，自然也要在created中调取。除了初始化的数据外，created还可以防止刷新数据丢失，实现函数为KeepInfor()。

![](pic\image-20230716103406002.png)

#### 		(2) data()

​			data()中存放了全部的数据结构，比如储存从后端调取的数据，用户在网页输入的数据或一些必要的状态和检索值。储存时不能弄混数据结构的类型。例如：

![](pic\image-20230716104142142.png)

#### 		(3) 其他函数

​			其他函数功能繁杂，类型众多，就不在手册中一一赘述。他们的功能是实现该文件所需要完成的任务，处理从网页或后端接口获取的数据，并转化为需要的接口并传给需要的位置。

####    3. style部分

​			该部分为css代码段，其功能是网页布局设计和美化。值得注意的是，在命名是要尽量不和其他文件设一个名字。如果设了同一个名字，也要保证这些数据完全相同，否则由于文件之间并不完全平等的关系，会导致本文件的style采用的是比它优先级跟高的文件里的同名style，从而导致在设计布局上出现意想不到的bug。除此之外，该部分的设计几乎没有技术上的难度，可以通过实际显示情况进行不断地微调。

### （三）tabs部分设计

​				由于该项目的单位是委托，所以用户主界面所有的单位都是委托，其中搜索依据是state。state的作用是记录该委托当前的状态，即已经进行到哪一步。具体的数值如下：

发起委托(委托修改) 10  市场部通过 11 测试部不通过 15  测试部通过 12 不通过 16   生成报价 20  客户接受报价 21 不接受 25

生成合同草稿 30  客户接受并填写合同 31 不接受 35    市场部审核通过 32 不通过36

用户发送样品 40  验收通过 41 不通过 45  测试部编写测试方案 50  质量部通过 51 不通过 55

填写测试文档 60  测试完成，生成测试报告 70  测试部主管通过 71 不通过 75  用户审核通过 72 不通过76  授权签字人 73 77

测试部归档 发送测试报告 80  确认接受 81

​	在相应的按钮下，代码会根据相应的state来寻找全部进程，再根据这些进程的ID找到委托的具体信息。点击导航栏的按钮后，会调用addtab()函数：

![](pic\image-20230716134217268.png)

调用后，该tabs的名称是targetName值，需要调用的vue文件是commentName，全部的文件格式都是表格，表格中列出了需要被处理委托的基本信息，格式如下：

![](pic\image-20230716134453983.png)

用户可以点击操作栏下的处理按钮进入到具体的执行页面

## 	二. 接口设计

### （一） 从后端接收数据

#### 	1.通过state确定PID

​	从后端获得数据的主要方式为checkbyPID。首先通过指定state，找到所有符合条件的PID，其中储存state的数据结构为：

![](pic\image-20230716135927909.png)

从后端传回的数据在ret.data中，如果需要打印到前端，则把数据存到ruleForm中。在本步骤中，返回的值为数组，数组中的内容为全部相应state的委托的PID，把对应委托的信息储存到ruleForm并且显示在tabs的表格中。

#### 	2. 通过state，FileType与PID确定FID

​		当需要下载文件时，为了可以做到精准的确定文件，我们首先需要PID确定是来自哪一个委托的文件，确定委托后，再确定来自哪一步，即state值，该state在file类中，与上一部分的state并不相同。确定了具体的位置后，还有确定是哪一个具体的文件，比如，在发起委托时，需要同时上传需求文档，用户文档和操作文档。FileType的功能就是确定同一个state下的多个文件各个的功能。具体的代码如下：

![](pic\image-20230716142511630.png)

#### 	3. 通过find()查找

​			如果需要根据特定的ID寻找委托，那么可以用一系列的find函数实现。比如，通过state是findbystate，通过UID是findByUID，通过PID是findByPID，通过AID是findByAID。这些函数的返回值都是数组，里面存了全部符合条件的委托的信息。

![](pic\image-20230716144557992.png)

### （二）向后端传输数据

####    1. 从网页中获取

​		对于用户传输的数据，代码中会传到ruleForm中，无论是从后端传到网页，还是从网页传到后端，都是通过ruleForm来传输。绝大部分的文件都是单向传输，但也有少量文件，如修改界面，也会出现双向传输的界面。向后端传输时，一般时通过点击提交按钮后，在submitForm函数中实现传输，示例如下：

![](pic\image-20230716143131317.png)

####    2. 使用接口

#### 		(1) insert()

​		如果该网页所传输的数据在此之前从没有被传到数据库中，那么调用insert函数即可，insert中保存了全部的数据，还要加上当前委托的PID，示例如下：

![](pic\image-20230716143456300.png)

#### 		(2) update()

​			如果前一步的方案被否决，那么需要用户修改方案，在界面中会把之前不通过的信息全部打印出来，并且允许用户进行修改，在用户修改完成后，点击完成按钮会调用submitform函数，函数中包含update函数，该函数可更改数据库中的数据，而修改的数据同样储存在ruleForm中，示例如下：

![](pic\image-20230716144033276.png)




----------------
#   后台设计简介
-----------------------
&emsp;&emsp;后台采用Springboot+Mybatis+Mysql的架构，使用Mysql作为数据库，Springboot完成API接口的具体实现，Mybatis作为持久层框架，进行二者间数据交流以及数据的持久化。使用的Springboot为3.1.0版本，Mybatis为3.0.1版本，Mysql为8.0.33版本。依赖文件相关内容如下：
```xml
<parent>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-parent</artifactId>
	<version>3.1.0</version>
	<relativePath/> <!-- lookup parent from repository -->
</parent>
<!--	sql -->
<dependency>
	<groupId>mysql</groupId>
	<artifactId>mysql-connector-java</artifactId>
	<version>8.0.33</version>
	<scope>runtime</scope>
</dependency>
<!--	mybatis-->
<dependency>
	<groupId>org.mybatis.spring.boot</groupId>
	<artifactId>mybatis-spring-boot-starter</artifactId>
	<version>3.0.1</version>
</dependency>
```
&emsp;&emsp;本项目后台的优点是：
&emsp;&emsp;1.结构清晰，进行清晰的分层，对文件依照针对的表名和所在层进行了统一化的命名，文件作用一目了然。
&emsp;&emsp;2.函数结构化强，对于多次使用的部分，封装成为函数，代码修改较为简单。
&emsp;&emsp;3.表单数据结构较为自由，尽量少使用enums、Array等容易因数据结构而产生500错误的结构，允许前台较大程度上修改自身表单内容而不产生报错。
&emsp;&emsp;4.接口命名规范性强，前台使用接口可以较为简单地理解接口含义，配合接口文档可以较为容易地使用接口。


------------------
##  后台代码结构简介
-------------------
&emsp;&emsp;后台代码采用四层架构，分别为Controller层、Service层、Dao层与Model层，其中对应经典的三层架构，Dao层对应数据访问层，Service层与Model层对应业务逻辑层，Controller层对应表示层。
###     Controller层
&emsp;&emsp;Controller层共定义21个类，除去测试接口连接使用的TestController类以及关联表单使用的ProcessController与ApplicationController类之外，其他类均各自对应前端一个表单，处理特定表单的增、删、改、查工作，其中定义的接口的作用以及使用规范清请参考《接口文档》。
###     Service层
&emsp;&emsp;每个Controller类对应一个Service类，Service类对从Controller层传来的JSONString进行处理，由于前端在JSONString的表单结构与数据命名上与后端和数据库有一定不同，所以需要对绝大部分变量进行重新命名。对于一些变量结构，也会做一定处理：
&emsp;&emsp;1.对于JSONObject中包含其他变量的JSONobject，会去掉JSONObject的打包，将其展开，例如：
```JSON
{
    "key1":"value1",
    "key2":"value2",
    "JSONObject":{
        "key3":"value3",
        "key4":"value4"
    }
}
```
处理为：
```JSON
{
    "key1":"value1",
    "key2":"value2",
    "key3":"value3",
    "key4":"value4"
}
```
在这其中的JSONObject与JSONArray，递归地进行处理，直到没有为止。

&emsp;&emsp;2.对于含有单个变量的JSONArray，直接作为String存储，例如：
```JSON
{
    "JSONArray":[
        "value1",
        "value2",
        "value3",
        ...
    ]
}
```
处理为：
```JSON
{
    "key1":"[value1,value2,value3,...]"
}
```
在这其中的JSONObject与JSONArray，递归地进行处理，直到没有为止。

&emsp;&emsp;3.对于只有一个只含有单个变量的JSONObject的JSONArray，直接展开后作为String存储，例如：
```JSON
{
    "JSONArray":[
        {
            "key":"value"
        },
        {
            "key":"value"
        },
        ...
    ]
}
```
处理为：
```JSON
{
    "key1":["value1","value2","value3",...]
}
```
在这其中的JSONObject与JSONArray，递归地进行处理，直到没有为止。

&emsp;&emsp;<a id = "4"></a>4.对于含有多个变量，或者含有有多个变量的JSONObject的JSONArray，为其中的每一个Array成员建立一个新的JSONObject，建立一个新的Mysql表将其存储，利用Mysql为其建立一个特异性id，同时在原JSONObject上建立一个JSONArray，存储对应的特异性id：
```JSON
{
    "JSONArray":[
        {
            "key1":"value1",
            "key2":"value2"
        },{
            "key1":"value1",
            "key2":"value2"
        },
        ...
    ]
}
```
处理为：
```JSON
父Object:
{
    "JSONArray":["id1","id2",...]
}

子JSONObject1:
{
    "id":"id1",
    "key1":"value1",
    "key2":"value2"
}
子JSONObject2:
{
    "id":"id2",
    "key1":"value1",
    "key2":"value2"
}
...
（其中JSONObject1和JSONObject2存入一个额外的Mysql表当中，id为Mysql返回的主键）
```
在这其中的JSONObject与JSONArray，递归地进行处理，直到没有为止。

&emsp;&emsp;同时，Service层还对上传失败，数据为空，查询失败等情况进行处理，合理地返回各类报错信息，尽可能避免前台收到500错误信息。
&emsp;&emsp;每个Service类都会调用ProcessDao，其余地，至少会使用自身对应的Dao层类，每因为上述第4点而需要额外建立Mysql表进行存储的，就需要额外使用一个Dao层类。

###     Dao层
&emsp;&emsp;每一个Dao类被一个Service类所调用（除去ProcessDao，它被所有Service类调用），同时对应一个Mysql的表。Dao层定义了后台与数据库之间的接口，使用Mybatis结合注解，省去了Mapper文件的定义。对于@Select注解的接口，Mybatis会自动调用对应Model文件中的setter函数，按顺序将Mysql返回的数据封装为对应Model的List。对于@Insert注解的接口，使用：
```java
@Options(useGeneratedKeys=true, keyProperty="ID", keyColumn="ID")
```
的注解，在Insert后，Mysql生成的id会被装入对应Model的ID中，
###     Model层
&emsp;&emsp;每一个Model类被一个Dao类调用，同时也被调用该Dao类的所有Service类调用。Model类定义每一个表单在后台的结构。其结构对应Service类处理后的数据结构，又与Mysql中对应的表保持一致。除去ID使用Integer类型之外，绝大部分数据以String类型定义，这样做的好处是允许前台更为自由地修改表单的规范，而不需要频繁地通知后台。同时也尽可能地避免了500报错（尤其相比于enum枚举类型而言），而代价仅仅是返回前台时需要进行数据转换而已。

------------------
后台代码UML类图如下图：
![MUL](./pic/demoUML.png)

--------------------------
## 后台数据处理流程
-----------------------

&emsp;&emsp;数据以JSON的形式传入Controller层，根据对应的接口，Controller层调用对应的Service层函数进行处理。所有的表都需要将ID存在Process下，因此，PID（对应委托进程的ID）是至关重要的，Service层首先查看数据当中是否拥有必要的PID，如果没有或者PID是无效的，那么会报错。如果没有问题，那么对传入数据进行处理，拆解JSONObject和Array结构，或者是依照[Service层结构简介第4点](#4)所说，产生额外的JSONObject。
&emsp;&emsp;如果执行的行为是新增（insert），如果产生了额外的JSONObject，那么，先交由子Object对应的Dao层进行存储，然后将对应的id存到父Object中。然后，交给对应的Dao层进行存储。存储之后，Dao层返回具体的ID，调用ProcessDao的对应函数，将ID存在Process下。
&emsp;&emsp;如果执行的行为是查找（select），修改（update）或者说删除（delete），那么根据PID查询对应的ID，然后再使用ID查找具体的信息，如果查找失败，那么报错（查找操作则是返回空Array）；否则，执行对应的操作，然后返回对应信息：查找是返回查找结果，修改和删除返回成功信息，如果是依照[Service层结构简介第4点](#4)所说，要对子Object进行修改，那么查找约定的操作字段，根据字段内容进行对应操作，如果失败，将会在返回信息中额外添加失败的id信息。
&emsp;&emsp;在返回查询过程中，也需要对数据重新命名和封装，这里采用的方式与Service层结构简介中所提到的对前台数据的处理是反向的。
&emsp;&emsp;返回的数据以JSON的形式，由Contorller层返回给前台。

--------------------------------

## 文件上传下载

###     实现概述

文件上传下载是本次项目的核心功能，除了需要实现服务器本地文件IO，还要通过以http协议与前端通信，是
本次实验的技术关键。

- **文件上传**

文件上传通过Spring框架中的`MultipartFile`实现，通过相关接口可轻松解决上传下载。

- `FileController`接收前端传参，转发给`Service`层处理
``` java
@CrossOrigin
@RequestMapping(value="/upload", method = RequestMethod.POST)
public Integer upload(@RequestParam("file") MultipartFile file,
                      @RequestParam("PID") Integer PID,
                      @RequestParam("state") String state,
                      @RequestParam("fileType") String fileType){
                        ...
                        return fileService.upload(file, PID, state, fileType);
                        ...
                      }
```

- `Service`层调用`Dao`层和`FileUtil`分别上传数据库和储存到本地

``` java
    public Integer upload(MultipartFile file, Integer PID, String state, String fileType) throws Exception{
        ...
        String fileName = file.getOriginalFilename();
        String filePath = fileUtil.uploadWithFileInfo(file, PID, state, fileType);
        //fileUtil将文件存储到本地并返回文件本地存储路径
        FileModel fileModel = new FileModel(filePath, PID, fileName);
        ...
        fileDao.upload(fileModel); //将文件信息经由DAO层上传到数据库
        return fileModel.getFID();
        ...
    }
```

- `FileUtil`将文件储存到本地

```java
    @ResponseBody
    public  String uploadWithFileInfo(@RequestPart(value = "file") MultipartFile mf,
                                      @RequestParam(value = "PID") Integer PID,
                                      @RequestParam(value = "state") String state,
                                      @RequestParam(value = "fileType") String fileType) throws IOException {
        //将文件上传到指定文件夹
        if (!mf.isEmpty()){
            String fileName=mf.getOriginalFilename();
            //文件上传
            String finalPath = UPLOAD_FILEPATH + PID.toString() + "\\" + state + fileType +  "_" + fileName ;
            // finalPath将文件信息写入文件名，避免重复命名覆盖
            File finalFile = new File(finalPath);
            if (!finalFile.exists())
                finalFile.mkdirs();
            mf.transferTo(new File(finalPath));
            return finalPath;
        }
        return "";
    }
```

- `FileDao` 将信息上传到mysql数据库
``` java
    @Insert("INSERT INTO selabspringe.file(filePath, PID, fileName, state, fileType) VALUES (#{filePath}, #{PID}, #{fileName}, #{state}, #{fileType})")
    @SelectKey(keyColumn = "FID", before = false, resultType = Integer.class, statement = {"select last_insert_id()"}, keyProperty = "FID")
    void upload(FileModel fileModel);
```

- **文件下载**

文件下载完全通过`FileController`处理，通过`HttpServletResponse`传输，通过文件stream缓冲区stream进行读取

``` java
    @CrossOrigin
    @RequestMapping(value = "/download", method = RequestMethod.POST)
    public String download(@RequestBody String postJson, HttpServletResponse response){
        //  新建文件流，从磁盘读取文件流
        JSONObject jsonObject = JSONObject.parseObject(postJson);
        Integer FID = jsonObject.getInteger("FID");
        FileModel fileModel = fileDao.selectByFID(FID);
        System.out.println(fileModel);
        if(fileModel == null) return "不存在FID为 "+FID.toString() + " 的文件";
        try (FileInputStream fis = new FileInputStream(fileModel.getFilePath());
             BufferedInputStream bis = new BufferedInputStream(fis);
             OutputStream os = response.getOutputStream()) {    
            // fis读取本地文件
            // OutputStream 是文件写出流，将文件下载到浏览器客户端
            // 新建字节数组，长度是文件的大小，比如文件 6kb, bis.available() = 1024 * 6
            byte[] bytes = new byte[bis.available()];
            // 从文件流读取字节到字节数组中
            bis.read(bytes);
            // 重置 response
            response.reset();
            // 设置 response 的下载响应头
            response.setHeader("Access-Control-Allow-Origin","*");
            response.setHeader("Access-Control-Expose-Headers", "Content-disposition");
            response.setContentType("application/octet-stream");
            response.setHeader("Content-disposition", "attachment;filename="
                    + URLEncoder.encode(fileModel.getFileName(), StandardCharsets.UTF_8));
            // 写出字节数组到输出流
            os.write(bytes);
            // 刷新输出流
            os.flush();
        } catch (Exception e) {

            return e.getMessage();
        }
        return "下载任务创建成功";
    }
```

------------------------

